<!DOCTYPE html>
<html>
<head>
<title>miniproject</title>
<link rel="stylesheet" type="text/css" href="style.css">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
 <div id="bannerimage" class="fixed">
 <div class="centerHeader">
 <hBanner>Miniproject: Location intelligence</hBanner>
 </div>
</div>
<div class="body">
	<div class="body1">
	<h1>Maps are a familiar way  of visualizing data</h1>
	<p>Maps are a familiar way of visualizing data to many people. Thus adding location to the data points has potential to make complex data better understandable. Moreover, knowledge of spatial relationships might reveal linkages that are not obvious from tables or bar charts.</p>
	<p>For companies and public organizations it is important to place their business right. You want you office or restaurant to be where the people are or where it is easy for them to get to.</p>
	<p>In our miniproject we visualized population and public transport stops on a map. Then weighted K-means algorithm was used to find population centers or transport hubs that could be optimal locations to place business units.
	</p>
	<p>After finding suitable coordinates we took open data about buildings and searched the buildings that are closest and have right purpose of usage.
	<h2>Warm up: clustering Finland</h2>
<p>On the scale of whole Finland we used k-means algorithm to find a set of locations to which some kind of facilities could be placed. The data used for this was 1 km x 1 km resolution data set of Finnish population from Statistics Finland (Tilastokeskus).</p>
<p>Simple and slow way of running k-means algorithm would be to give it for each person one data point with coordinates of the square kilometer they're living. Instead of this we used a weighted k-means algorithm, where each point has a numerical weight, which in practice tells how many different points that one point represents. This way we were able to use only approximately 100 000 data points, one for each inhabited square kilometer, weights being the number of people living at each square kilometer.</p>
<p>K-means algorithm alternates between calculating the mean of the points in each of the k clusters, and dividing the points into new clusters based on distances to the new means. When the clusters and means no longer change (it's easy to prove that the changing has to stop at some point), the algorithm returns the final k means (or equivalently, the final k clusters). It is an easy to prove fact that the mean of points minimizes the sum of squared distances (equivalently, the average of squared distances) from single location to each of the points. So k-means tries to minimize the average squared distance to the closest mean/location. In reality, it's probably better idea to try to minimize the average distance (not squared distance) to the closest location. Besides k-means algorithm, we used also <a href="https://en.wikipedia.org/wiki/K-medians_clustering">k-medians</a> algorithm, which almost does that, by trying to minimize the average l<sub>1</sub> distance (also known as taxicab or Manhattan distance).</p>
<p>The k-means (and k-medians) algorithm starts with random initial means, and thus produces (possibly) different results at each run. Because of this, we ran the algorithm multiple times, choosing the result with smallest average distance to the closest mean/median. You can see these precomputed results, or calculate new set of locations with either weighted k-means or k-medians algorithm, using this web app: <a href="https://where-to-place.herokuapp.com">where-to-place.herokuapp.com</a></p>
<p>Basic k-means algorithm can be found from many programming libraries, but weighted k-means and k-medians algorithms are a different story. We ended up writing the weighted k-means and k-medians algorithms from scratch. (Using Clojure/ClojureScript, so that you can run the algorithms in your own browser using the above mentioned <a href="https://where-to-place.herokuapp.com">web app</a>.)</p>
	<p>Here is an example of 18 clusters.</p>
	<p><img src="whereToPlace.png" alt="Finland and 18 counties by kmeans"></p>
	<h2>Visualizing population and bus stops in Helsinki metropolitan area</h2>
	<p>For many problems it is enough to have a good visualization. Thus we first drew population, bus stops, road and municipality bounds on to map.</p>
	<figure>
	<figcaption>Population 15 and under in Helsinki. The darker the area the denser the population.</figcaption>
	<img src="childrenVisual.png" alt="Youngsters under 15 in Helsinki">	
	</figure>
	<figcaption>HSL bus stops and municipality borders.</figcaption>
	<img src="hslpysakit.png" alt="HSL busstops on a map">	
	</figure>
	<h2>Optimal points and location suggestions</h2>

	<h2>Data wrangling and tools</h2>
	<p>There's a great interface from open street map data to python that makes it really easy to access geo-data like roads.</p>
	<p>Our starting point was 1 km by 1 km data set from Statistics Finland that includes total population and population by 3 agegroups as variables. We chose the version where coordinates depict the center of each square. Municipality border polygons or <em>statistical classification of municipalities</em> were also Statiscs Finland's open data.</p>
	<p>We got the data about bus stops from open street map interface but we used also HSL's open data collection.</p>
	<p>Our third main data set were the buildings of Helsinki, Espoo and Vantaa. These sets turned out to be utter nightmare. Eventhough there exists a 3-level official classification about the purpose of use of a building there three cities had managed to code it differently. Statistics Finland offered a list of codes that had to be parsed to unify the codes. Moreover the column names in the datasets were unnecessarily long and Vantaa had even used Scandinavian characters. So if our data wrangling quota for this exercise was not full after handling the building data it was.</p>
	<p>There's plenty of open data available but many interesting sets report things by municipality which is not so interesting with this kind of application. Statistics Finland has published an interesting data where zip code is the unit and variables include for example income. But this level was a little too abstract for us as well.</p>
	<p>Our main tools included Python 3 and Clojure/ClojureScript. HTML and CSS were obviously used to create this blog.</p>
	<h2>Improvents that we didn't have time to do</h2>
	<p>	<ul>
	<li>It would nice to interactive visualizations that would show information as you hoover over a point with mouse.</li>
	<li>More accurate time about traveling times would make our suggestions better.</li>
	<li>There's no information what is for sale and thus our suggested buildings might not be available at all.</li>
	</ul></p>	
	<h3>Read more: </h3>
	<p>
	<ul>
	<li><a href="https://www.forbes.com/sites/forbesinsights/2017/01/19/location-intelligence-mapping-the-opportunities-in-the-data-landscape/">Location Intelligence: Mapping The Opportunities In The Data Landscape (Forbes)</a>
	</li>
	<li><a href ="https://medium.com/towards-data-science/clustering-the-us-population-observation-weighted-k-means-f4d58b370002">Clustering the US population: observation-weighted k-means</a></li>
	</ul>
	</p>
	</div>
</div>
</html>
